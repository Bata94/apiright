package core

import (
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

var defCatchallHandler = func(c *Ctx) error {
	log.Info("Default CatchAll Handler, URL: ", c.Request.URL.String())
	c.Response.SetStatus(404)
	c.Response.Message = "Not found!"
	return nil
}

func newRouter(path string) *Router {
	return &Router{
		basePath: path,
	}
}

// Router is a router for the application.
type Router struct {
	groups []*Router
	routes []*Route

	basePath    string
	middlewares []Middleware
}

// Use adds a middleware to the router.
func (r *Router) Use(m Middleware) {
	r.middlewares = append(r.middlewares, m)
}

// GetBasePath returns the base path of the router.
func (r Router) GetBasePath() string {
	if len(r.basePath) > 1 {
		if string(r.basePath[len(r.basePath)-1]) != "/" {
			return fmt.Sprintf("%s/", r.basePath)
		}
	} else if r.basePath == "" {
		return "/"
	}
	return r.basePath
}

// GET adds a GET endpoint to the router.
func (r *Router) GET(path string, handler Handler, opt ...RouteOption) {
	r.addEndpoint(METHOD_GET, path, handler, opt...)
}

// POST adds a POST endpoint to the router.
func (r *Router) POST(path string, handler Handler, opt ...RouteOption) {
	r.addEndpoint(METHOD_POST, path, handler, opt...)
}

// PUT adds a PUT endpoint to the router.
func (r *Router) PUT(path string, handler Handler, opt ...RouteOption) {
	r.addEndpoint(METHOD_PUT, path, handler, opt...)
}

// DELETE adds a DELETE endpoint to the router.
func (r *Router) DELETE(path string, handler Handler, opt ...RouteOption) {
	r.addEndpoint(METHOD_DELETE, path, handler, opt...)
}

// OPTIONS adds an OPTIONS endpoint to the router.
func (r *Router) OPTIONS(path string, handler Handler, opt ...RouteOption) {
	r.addEndpoint(METHOD_OPTIONS, path, handler, opt...)
}

// Redirect adds a redirect to the router.
func (r *Router) Redirect(path, targetURL string, code int) {
	h := func(c *Ctx) error {
		c.Response.Redirect(targetURL, code)
		return nil
	}
	r.addEndpoint(METHOD_GET, path, h, WithOpenApiDisabled())
}

// TODO: Add a ReadMulti method to the CrudInterface and implement corresponding router functionality to allow fetching multiple resources based on criteria.
// TODO: Add BulkUpdate, BulkDelete, and BulkCreate methods to the CrudInterface and implement corresponding router functionalities for efficient batch operations.
// TODO: Implement a mechanism to allow setting individual RouteOptions for each endpoint generated by the CRUD function, overriding the general CRUD options.
type CrudInterface interface {
	CreateFunc(any) (any, error)
	ReadAllFunc() ([]any, error)
	ReadOneFunc(any) (any, error)
	UpdateFunc(any, any) (any, error)
	DeleteFunc(any) (any, error)
}

// Add full CreateReadUpdateDelete Endpoints, for the basePath and given CrudInterface.
// Only adding Endpoints, for defined functions in CrudInterface.
// RouteOptions will be applied to all, for individual Options will be added later.
// POST   {basePath}/{id} -> Create
// GET    {basePath}/     -> ReadAll
// GET    {basePath}/{id}	-> ReadOne
// PUT    {basePath}/{id}	-> Update
// DELETE {basePath}/{id} -> Delete
// func (r *Router) CRUD(basePath string, ci CrudInterface, opt ...RouteOption) {
// 	pathWithID := fmt.Sprintf("%s/{id}", basePath)
//
// 	if ci.CreateFunc != nil {
// 		r.addEndpoint(METHOD_POST, pathWithID, ci.CreateFunc, opt...)
// 	}
// }

// StaticSevFileConfig holds the configuration for serving a static file.
type StaticSevFileConfig struct {
	preLoad         bool
	preCache        bool
	maxPreCacheSize int64
	forcePreCache   bool
	contentType     string
	indexFile       string
	// TODO: Add more ConfigOptions
	// disableFileExplorer bool
	// includeHiddenFiles bool
	// excludeFiles []strings // as regex
	// excludeDirs []strings // as regex
	// customCssFile string
	// TODO: add compression on startup or on the fly based on "preLoaded"
	// compress bool
	// compressLevel int
	// compressType string
}

// StaticServFileOption is a function that configures a StaticSevFileConfig.
type StaticServFileOption func(*StaticSevFileConfig)

// NewStaticServeFileConfig creates a new StaticSevFileConfig.
func NewStaticServeFileConfig(opts ...StaticServFileOption) *StaticSevFileConfig {
	c := &StaticSevFileConfig{
		preLoad:         true,
		preCache:        true,
		maxPreCacheSize: 1024 * 1024 * 10, // 10 MB
		forcePreCache:   false,
		contentType:     "",
		indexFile:       "index.html",
	}

	for _, opt := range opts {
		opt(c)
	}

	if c.preCache && !c.preLoad {
		log.Fatal("Cannot set PreCache without PreLoad!")
	}

	if c.forcePreCache {
		log.Debug("Pre-caching files on startup.")
		c.preCache = true
	}

	return c
}

// WithoutPreLoad it will not look if files exits on startup! Be careful if using this option with a Directory, this function will expose all files in the directory, even if created after Server start!
// This will also disable pre-caching.
func WithoutPreLoad() StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.preLoad = false
		c.preCache = false
	}
}

// WithoutPreCache it will not cache files on startup.
func WithoutPreCache() StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.preCache = false
	}
}

// WithPreCache it will load files into memory on startup, even if bigger than the maxPreCacheSize.
// Caching will mainly reduce latency. With NVME drives, the speed difference is negligible.
func WithPreCache() StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.preCache = true
		c.forcePreCache = true
	}
}

// WithPreCacheSize sets the maximum size of the pre-cache.
func WithPreCacheSize(size int64) StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.preCache = true
		c.maxPreCacheSize = size
	}
}

// WithContentType sets the content type of the file.
func WithContentType(contentType string) StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.contentType = contentType
	}
}

// WithIndexFile sets the index file for the directory.
func WithIndexFile(indexFile string) StaticServFileOption {
	return func(c *StaticSevFileConfig) {
		c.indexFile = indexFile
	}
}

// loadFile loads a file from the given path.
// It returns the file, the file info, and an error if any.
// Remember to close the file after use, best use the closeFile function.
func loadFile(p string) (*os.File, os.FileInfo, error) {
	var (
		f     *os.File
		fInfo os.FileInfo
		err   error
	)
	fInfo, err = os.Stat(p)
	if os.IsNotExist(err) {
		err = fmt.Errorf("static file '%s' does not exist. Please ensure the file exists", p)
		goto Return
	}

	f, err = os.Open(p)
	if err != nil {
		err = fmt.Errorf("static file '%s' exists, but is not readable: %w", p, err)
		goto Return
	}

Return:
	return f, fInfo, err
}

func closeFile(f *os.File) {
	err := f.Close()
	if err != nil {
		log.Panic("Failed to close file: ", err)
	}
}

// ServeStaticFile serves a static file.
func (r *Router) ServeStaticFile(urlPath, filePath string, opt ...StaticServFileOption) {
	var h Handler
	config := NewStaticServeFileConfig(opt...)
	absFilePath, err := filepath.Abs(filePath)
	if err != nil {
		log.Fatalf("Error resolving absolute path for static file %s: %v", filePath, err)
	}

	if config.preLoad {
		log.Debugf("Attempting to serve static file from absolute path: %s", absFilePath)

		f, fInfo, err := loadFile(absFilePath)
		defer closeFile(f)
		if err != nil {
			log.Fatal("static file '%s' does not exist. Please ensure the file exists", absFilePath)
		}

		if config.preCache {
			if config.forcePreCache || fInfo.Size() <= config.maxPreCacheSize {
				log.Debug("Pre-caching file: ", absFilePath)
				content, err := io.ReadAll(f)
				if err != nil {
					log.Error("static file '%s' exists, but is not readable: %w", absFilePath, err)
				}

				h = func(c *Ctx) error {
					c.Response.SetStatus(200)
					c.Response.SetData(content)
					c.Response.AddHeader("Content-Type", config.contentType)
					return nil
				}
			}
		}

		if h == nil {
			h = func(c *Ctx) error {
				f, err := os.Open(absFilePath)
				defer closeFile(f)
				if err != nil {
					c.Response.SetStatus(404)
					c.Response.SetMessage("File not found... Please double-check the URL and try again.")
					return nil
				}

				content, err := io.ReadAll(f)
				if err != nil {
					if errors.Is(err, os.ErrNotExist) {
						c.Response.SetStatus(404)
						c.Response.SetMessage("File not found... Please double-check the URL and try again.")
						return nil
					}
					err = fmt.Errorf("static file '%s' exists, but is not readable: %w", absFilePath, err)
					log.Error(err)

					c.Response.SetStatus(500)
					c.Response.SetMessage("File was found, but is not readable... Please try again later, if it persists, contact the administrator.")
					return nil
				}

				c.Response.SetStatus(200)
				c.Response.SetData(content)
				c.Response.AddHeader("Content-Type", config.contentType)
				return nil
			}
		}
	} else {
		h = func(c *Ctx) error {
			f, _, err := loadFile(absFilePath)
			defer closeFile(f)
			if err != nil {
				c.Response.SetStatus(404)
				c.Response.SetMessage("File not found... Please double-check the URL and try again.")
				return nil
			}

			content, err := io.ReadAll(f)
			if err != nil {
				err = fmt.Errorf("static file '%s' exists, but is not readable: %w", absFilePath, err)
				log.Error(err)

				c.Response.SetStatus(500)
				c.Response.SetMessage("File was found, but is not readable... Please try again later, if it persists, contact the administrator.")
				return nil
			}

			c.Response.SetStatus(200)
			c.Response.SetData(content)
			c.Response.AddHeader("Content-Type", config.contentType)
			return nil
		}

	}
	r.addEndpoint(
		METHOD_GET,
		urlPath,
		h,
		WithOpenApiDisabled(),
	)
}

// TODO: Better Breadcrumbs
// TODO: Move out css to a separate file
const dirExplorerTemplate = `
{{$BaseUrl := .BaseUrl}}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>{{.Title}} - File Explorer</title>
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <style>
      :root {
        --primary-color: #007bff;
        --secondary-color: #6c757d;
        --background-color: #f8f9fa;
        --card-background: #ffffff;
        --border-color: #dee2e6;
        --text-color: #343a40;
        --link-color: #007bff;
        --link-hover-color: #0056b3;
        --header-bg: #e9ecef;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol";
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--background-color);
        margin: 0;
        padding: 0;
      }

      .container {
        max-width: 960px;
        margin: 20px auto;
        padding: 0 15px;
      }

      header {
        background-color: var(--header-bg);
        padding: 20px 0;
        border-bottom: 1px solid var(--border-color);
        text-align: center;
      }

      header h1 {
        margin: 0;
        color: var(--primary-color);
      }

      .file-list {
        list-style: none;
        padding: 0;
        margin-top: 20px;
        background-color: var(--card-background);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }

      .file-item {
        display: flex;
        align-items: center;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.2s ease;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-item:hover {
        background-color: #f1f3f5;
      }

      .file-item a {
        text-decoration: none;
        color: var(--link-color);
        display: flex;
        align-items: center;
        flex-grow: 1;
      }

      .file-item a:hover {
        color: var(--link-hover-color);
      }

      .file-icon {
        width: 24px;
        text-align: center;
        margin-right: 15px;
        color: var(--secondary-color);
      }

      .file-icon.folder {
        color: #ffc107; /* Yellow for folders */
      }

      .file-name {
        flex-grow: 1;
        font-weight: 500;
      }

      .file-size {
        font-size: 0.9em;
        color: var(--secondary-color);
        margin-left: 15px;
      }

      .path-breadcrumb {
        margin-top: 15px;
        padding: 10px 20px;
        background-color: var(--header-bg);
        border-radius: 5px;
        font-size: 0.9em;
      }

      .path-breadcrumb a {
        text-decoration: none;
        color: var(--primary-color);
      }

      .path-breadcrumb span {
        color: var(--secondary-color);
      }

      .path-breadcrumb a:hover {
        text-decoration: underline;
      }

      footer {
        text-align: center;
        margin-top: 40px;
        padding: 20px;
        color: var(--secondary-color);
        font-size: 0.8em;
      }

      @media (max-width: 768px) {
        .file-item {
          flex-wrap: wrap;
        }
        .file-size {
          margin-left: 0;
          width: 100%;
          text-align: right;
          font-size: 0.85em;
          padding-top: 5px;
        }
        .file-name {
          flex-basis: calc(100% - 39px); /* icon width + margin */
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="container">
        <h1><i class="fas fa-folder-open"></i> {{.Title}}</h1>
      </div>
    </header>
    <main class="container">
      <nav class="path-breadcrumb">
        <!-- Example Breadcrumb (You'll need to pass this data from Go) -->
        <!-- For now, assuming Title is the current path -->
        You are in:
        <a href="{{$BaseUrl}}">Home</a>
        {{- if ne .Title "/"}}
          <span> / </span>
          <span>{{.Title}}</span>
        {{- end}}
      </nav>

      <ul class="file-list">
				{{range .Dirs}}
					<li class="file-item">
						<a href="{{$BaseUrl}}{{.Name}}/">
							<span class="file-icon">
								<i class="fas fa-folder folder"></i>
							</span>
							<span class="file-name">{{.Name}}</span>
						</a>
					</li>
				{{end}}

        {{range .Files}}
          <li class="file-item">
            <a href="{{$BaseUrl}}{{.DirPath}}{{.Name}}">
              <span class="file-icon">
                {{if (hasSuffix .Name ".pdf")}}
                  <i class="fas fa-file-pdf"></i>
                {{else if (or (hasSuffix .Name ".png") (hasSuffix .Name ".jpg") (hasSuffix .Name ".jpeg") (hasSuffix .Name ".gif"))}}
                  <i class="fas fa-file-image"></i>
                {{else if (or (hasSuffix .Name ".zip") (hasSuffix .Name ".rar") (hasSuffix .Name ".7z"))}}
                  <i class="fas fa-file-archive"></i>
                {{else if (or (hasSuffix .Name ".doc") (hasSuffix .Name ".docx"))}}
                  <i class="fas fa-file-word"></i>
                {{else if (or (hasSuffix .Name ".xls") (hasSuffix .Name ".xlsx"))}}
                  <i class="fas fa-file-excel"></i>
                {{else if (or (hasSuffix .Name ".ppt") (hasSuffix .Name ".pptx"))}}
                  <i class="fas fa-file-powerpoint"></i>
                {{else if (or (hasSuffix .Name ".txt") (hasSuffix .Name ".md") (hasSuffix .Name ".go") (hasSuffix .Name ".html") (hasSuffix .Name ".css") (hasSuffix .Name ".js") (hasSuffix .Name ".json") (hasSuffix .Name ".xml"))}}
                  <i class="fas fa-file-code"></i>
                {{else if (or (hasSuffix .Name ".mp3") (hasSuffix .Name ".wav"))}}
                  <i class="fas fa-file-audio"></i>
                {{else if (or (hasSuffix .Name ".mp4") (hasSuffix .Name ".mov") (hasSuffix .Name ".avi"))}}
                  <i class="fas fa-file-video"></i>
                {{else}}
                  <i class="fas fa-file"></i>
                {{end}}
              </span>
              <span class="file-name">{{.Name}}</span>
              <span class="file-size">
								{{.Size | byteFormat}}
              </span>
            </a>
          </li>
        {{end}}
      </ul>
			{{if and (eq (len .Files) 0) (eq (len .Dirs) 0)}}
        <p style="text-align: center; color: var(--secondary-color);">
          This directory is empty.
        </p>
      {{end}}
    </main>
    <footer>
      <p>ApiRight File Explorer</p>
    </footer>
  </body>
</html>
`

type DirTemplateData struct {
	Title           string
	BaseUrl         string
	IndexFileExists bool
	Files           []FileData
	Dirs            []DirData
}

type FileData struct {
	DirPath string
	Name    string
	Size    int64
}

type DirData struct {
	Name string
}

// setupTemplateFuncs creates and returns a template.FuncMap
// containing our custom functions.
func setupTemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"hasSuffix": func(s, suffix string) bool {
			return strings.HasSuffix(s, suffix)
		},
		"byteFormat": func(b int64) string {
			const unit = 1024
			if b < unit {
				return fmt.Sprintf("%d B", b)
			}
			div, exp := int64(unit), 0
			for n := b / unit; n >= unit; n /= unit {
				div *= unit
				exp++
			}
			// KMGTPE represents Kilo, Mega, Giga, Tera, Peta, Exa
			return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
		},
	}
}

// TODO: Refactor Inputs
func (r *Router) getStaticDirData(baseDirPath, dirPath, baseUrl string, config *StaticSevFileConfig, a App, addStaticRoutes bool, opt ...StaticServFileOption) (DirTemplateData, error) {
	dirData := DirTemplateData{
		Title:           "ApiRight", // TODO: Add title from AppConfig
		BaseUrl:         baseUrl,
		IndexFileExists: false,
		Files:           []FileData{},
		Dirs:            []DirData{},
	}
	files, err := os.ReadDir(dirPath)
	if err != nil {
		panic(err)
	}

	if len(files) == 0 {
		panic("Directory is empty: " + dirPath)
	}

	for _, file := range files {
		if file.Name() == config.indexFile {
			dirData.IndexFileExists = true
			break
		}
	}

	for _, file := range files {
		if file.IsDir() {
			dirData.Dirs = append(dirData.Dirs, DirData{
				Name: file.Name(),
			})
			if addStaticRoutes {
				r.ServeStaticDir(baseUrl+file.Name(), filepath.Join(dirPath, file.Name()), a, opt...)
			}
			continue
		}
		fInfo, err := file.Info()
		if err != nil {
			panic(err)
		}
		size := fInfo.Size()
		fd := FileData{
			DirPath: strings.TrimPrefix(dirPath, baseDirPath),
			Name:    file.Name(),
			Size:    size,
		}

		if !strings.HasSuffix(fd.DirPath, "/") && fd.DirPath != "" {
			fd.DirPath += "/"
		}
		dirData.Files = append(dirData.Files, fd)

		if addStaticRoutes {
			r.ServeStaticFile(baseUrl+file.Name(), filepath.Join(dirPath, file.Name()), opt...)
		}
	}

	return dirData, nil
}

func decideStaticIndexFile(dirData DirTemplateData, dirPath string, dirTempl *template.Template, config *StaticSevFileConfig) []byte {
	buf := new(bytes.Buffer)
	if dirData.IndexFileExists {
		indexFileContent, err := os.ReadFile(filepath.Join(dirPath, config.indexFile))
		if err != nil {
			panic(err)
		}
		buf.Write(indexFileContent)
	} else {
		if err := dirTempl.Execute(buf, dirData); err != nil {
			panic(err)
		}
	}
	return buf.Bytes()
}

// ServeStaticDir serves a directory at the given URL path.
// If the directory contains a "index.html" file, it will be served as "/" route. If not a FileExplorer will be shown, by default.
// It is highly recommended to leave the PreLoad option enabled.
func (r *Router) ServeStaticDir(urlPath, dirPath string, a App, opt ...StaticServFileOption) {
	var h Handler
	a.Logger.Debug("üìÅ Serving static directory: ", dirPath, " at: ", urlPath)
	config := NewStaticServeFileConfig(opt...)

	dirTempl, err := template.New(urlPath).Funcs(setupTemplateFuncs()).Parse(dirExplorerTemplate)
	if err != nil {
		panic(err)
	}

	pattern := urlPath
	if !strings.HasSuffix(pattern, "/") {
		pattern += "/"
	}

	if config.preLoad {
		dirData, err := r.getStaticDirData(dirPath, dirPath, pattern, config, a, true, opt...)
		if err != nil {
			log.Fatal(err)
			return
		}

		if config.forcePreCache || config.preCache {
			content := decideStaticIndexFile(dirData, dirPath, dirTempl, config)
			h = func(c *Ctx) error {
				c.Response.SetStatus(200)
				c.Response.SetData(content)
				c.Response.AddHeader("Content-Type", "text/html")

				return nil
			}
		} else {
			h = func(c *Ctx) error {
				content := decideStaticIndexFile(dirData, dirPath, dirTempl, config)

				c.Response.SetStatus(200)
				c.Response.SetData(content)
				c.Response.AddHeader("Content-Type", "text/html")

				return nil
			}
		}
	} else {
		h = func(c *Ctx) error {
			var (
				content []byte
				err     error
			)

			if strings.HasSuffix(c.Request.URL.Path, "/") {
				var dirData DirTemplateData
				dirData, err = r.getStaticDirData(dirPath, dirPath+strings.TrimPrefix(c.Request.URL.Path, urlPath+"/"), pattern, config, a, false, opt...)
				if err != nil {
					log.Error(err)
					return err
				}
				content = decideStaticIndexFile(dirData, dirPath+strings.TrimPrefix(c.Request.URL.Path, urlPath+"/"), dirTempl, config)
			} else {
				a.Logger.Debug("üìÅ Serving static directory: ", dirPath, " at: ", urlPath)
				a.Logger.Debugf("Current URLPath %s", c.Request.URL.Path)

				content, err = os.ReadFile(dirPath + strings.TrimPrefix(c.Request.URL.Path, urlPath+"/"))
				if err != nil {
					log.Error(err)
					if errors.Is(err, os.ErrNotExist) {
						c.Response.SetStatus(404)
						c.Response.SetMessage("File not found... Please double-check the URL and try again.")
						return nil
					}
					return err
				}
			}

			c.Response.SetStatus(200)
			c.Response.SetData(content)
			c.Response.AddHeader("Content-Type", "text/html")

			return err
		}
	}
	a.Redirect(urlPath, urlPath+"/", http.StatusMovedPermanently)
	r.GET(urlPath+"/", h)
}

func (r *Router) routeExists(path string) int {
	// Checks if route exists and returns the index. If false -1 is returned.
	for i, route := range r.routes {
		if route.path == path {
			return i
		}
	}

	return -1
}

func (r *Router) addEndpoint(m RequestMethod, p string, h Handler, opt ...RouteOption) {
	routeConfig := NewRouteOptionConfig(opt...)
	routeIndex := r.routeExists(p)

	if routeIndex == -1 {
		var endpoints []Endpoint
		if p != "/" {
			optionEP := Endpoint{
				method: METHOD_OPTIONS,
				handleFunc: func(c *Ctx) error {
					c.Response.SetStatus(http.StatusOK)
					return nil
				},
				routeOptionConfig: RouteOptionConfig{},
			}
			endpoints = []Endpoint{optionEP}
		} else {
			endpoints = []Endpoint{}
		}

		r.routes = append(r.routes, &Route{
			basePath:  p,
			path:      fmt.Sprint(r.basePath, p),
			endpoints: endpoints,
		})

		routeIndex = len(r.routes) - 1
	}

	// Prevent adding duplicate OPTIONS endpoint if it already exists
	if m == METHOD_OPTIONS {
		for _, ep := range r.routes[routeIndex].endpoints {
			if ep.method == METHOD_OPTIONS {
				return
			}
		}
	}

	r.routes[routeIndex].endpoints = append(r.routes[routeIndex].endpoints, Endpoint{
		method:            m,
		handleFunc:        h,
		routeOptionConfig: *routeConfig,
		middlewares:       routeConfig.middlewares,
	})
}
